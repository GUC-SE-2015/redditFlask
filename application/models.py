"""
We define all of our models here
"""
from . import db, app
from flask.ext.bcrypt import generate_password_hash, check_password_hash
from itsdangerous import TimedJSONWebSignatureSerializer, SignatureExpired, BadSignature

# Secondary table for subscriptions
subscriptions = db.Table('subscriptions',
                         db.Column(
                             'user_username', db.String(256), db.ForeignKey('user.username')),
                         db.Column('subreddit_name', db.String(
                             256), db.ForeignKey('subreddit.name'))
                         )

# Association object for Karma


class Vote(db.Model):
    voter_username = db.Column(
        db.String(256), db.ForeignKey('user.username'), primary_key=True)
    entry_id = db.Column(
        db.Integer, db.ForeignKey('entry.id'), primary_key=True)
    weight = db.Column(db.Integer)

    def __init__(self, voter=None, up=True, entry=None):
        self.weight = 1 if up else -1
        self.voter_username = voter.username
        self.entry_id = entry.id
        super(Vote, self).__init__()


class User(db.Model):

    """
    We are using username as primary_key here for semantic sense.
    However it is important to note that using autogenerated integers make index
    maintenence much easier.
    """
    username = db.Column(db.String(256), primary_key=True)
    password_hash = db.Column(db.String(60), unique=True, nullable=False)
    entries = db.relationship('Entry', backref='author')
    votes = db.relationship('Vote', lazy='dynamic', backref='voter')

    def __init__(self, username=None, password=None):
        self.username = username
        if password is not None:
            self.password = password
        super(User, self).__init__()

    @property
    def karma(self):
        sums = [post.votes.with_entities(
            db.func.sum(Vote.weight).label('sum')).all()[0][0] for post in self.entries]
        return sum(sums)

    def to_dict(self):
        return {
            "username": self.username,
            "subscriptions": [s.to_dict() for s in self.subscriptions],
            "posts": [e.to_dict() for e in self.entries if isinstance(e, Post)],
            "comments": [e.to_dict() for e in self.entries if not isinstance(e, Post)],
            "karma": self.karma
        }

    @property
    def password(self):
        """Returns hash, not actual password."""
        return self.password_hash

    @password.setter
    def password(self, value):
        """Hashes password."""
        self.password_hash = generate_password_hash(value, 12)

    def verify_pass(self, password):
        """Checks if a password matches the stored hash"""
        return check_password_hash(self.password_hash, password)

    def generate_auth_token(self, expires_in):
        """
        Creates an expiring token that can identify this user.
        expires_in is expiration in minutes.
        """
        serializer = TimedJSONWebSignatureSerializer(
            app.config['SECRET_KEY'], expires_in=expires_in * 60)
        return serializer.dumps({'username': self.username})

    @staticmethod
    def verify_auth_token(token):
        """
        Retrieves user who is identified by this token.
        Raises SignatureExpired, BadSignature if expired or malformed.
        """
        serializer = TimedJSONWebSignatureSerializer(app.config['SECRET_KEY'])
        data = serializer.loads(token)
        user = User.query.get(data['username'])
        if user is None:
            raise BadSignature("Could not identify owner.")
        return user


class Subreddit(db.Model):
    name = db.Column(db.String(256), primary_key=True)
    subscribers = db.relationship(
        'User', secondary=subscriptions, backref=db.backref('subscriptions'))
    posts = db.relationship('Post', backref='subreddit')

    def __init__(self, name=None):
        self.name = name
        super(Subreddit, self).__init__()

    def to_dict(self):
        return {
            "name": self.name,
            "posts": [p.to_dict() for p in self.posts]
        }


class Entry(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_username = db.Column(db.String(256), db.ForeignKey('user.username'))
    body = db.Column(db.Text)
    parent_id = db.Column(db.Integer, db.ForeignKey('entry.id'))
    parent = db.relationship(
        'Entry', backref=db.backref('comments', lazy='dynamic'), remote_side=[id])
    type = db.Column('type', db.String(128))  # discriminator
    votes = db.relationship('Vote', lazy='dynamic', backref='entry')

    @property
    def upvotes(self):
        return self.votes.filter(Vote.weight == 1).count()

    @property
    def downvotes(self):
        return self.votes.filter(Vote.weight == -1).count()

    def __init__(self, body=None):
        self.body = body
        super(Entry, self).__init__()

    def to_dict(self):
        return {
            "id": self.id,
            "body": self.body,
            "comments": [c.to_dict() for c in self.comments],
            "author": self.author.username,
            "upvotes": self.upvotes,
            "downvotes": self.downvotes
        }

    __mapper_args__ = {
        'polymorphic_identity': 'entry',
        'polymorphic_on': type
    }


class Post(Entry):
    id = db.Column(db.Integer, db.ForeignKey('entry.id'), primary_key=True)
    title = db.Column(db.String(512), index=True, nullable=False)
    subreddit_name = db.Column(db.String(256), db.ForeignKey('subreddit.name'))
    __mapper_args__ = {
        'polymorphic_identity': 'post'
    }

    def __init__(self, title=None, **kwargs):
        self.title = title
        super(Post, self).__init__(**kwargs)

    def to_dict(self):
        dic = super(Post, self).to_dict()
        dic['title'] = self.title
        dic['subreddit'] = self.subreddit.name
        return dic
